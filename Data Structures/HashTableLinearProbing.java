// CMPS 390// HashTableLinearProbing.java// Kuo-pao Yang/*   Linear Probing: Resolves a collision during hashing by examining consecutive       locations in the hash table, beginning at the original hash index and       locating the next available location.    hashTable[k], hashTable[k+1], hashTable[k+2], and so on. */public class HashTableLinearProbing {	private TableEntry[] hashTable;  	private int currentSize;         // current number of entries	private static final int DEFAULT_SIZE = 101; // must be prime	// fraction of hash table that can be filled	private static final double MAX_LOAD_FACTOR = 0.5; 	public HashTableLinearProbing()	{		hashTable = new TableEntry[DEFAULT_SIZE];		currentSize = 0;	} // end default constructor	public HashTableLinearProbing(int tableSize) {		// table is prime size >= user wants		int primeSize = getNextPrime(tableSize);		hashTable = new TableEntry[primeSize];		currentSize = 0;	} // end constructor	public Object add(Object key, Object value)	{		Object oldValue; // value to return		if (isHashTableTooFull())			rehash();		int i = getHashIndex(key);		i = probe(i, key); // check and resolve collision		if ((hashTable[i] == null) || hashTable[i].isRemoved()){          // key not found: insert new entry			hashTable[i] = new TableEntry(key, value);			currentSize++;			oldValue = null;		}		else {          // key found: get old value for return and replace new value			oldValue = hashTable[i].getValue();			hashTable[i].setValue(value);		} // end if		return oldValue;	} // end add   	/** Task: Resolves a collision during hashing by examining consecutive      *   locations in the hash table     * @param the hash index (from the key) and the key      * @return either the index of next available location	  *   (key found, removed, or null),      *   or -1 if no such entry is found */	private int probe(int index, Object key) {      boolean repeated = false;      int i = index;		while (!repeated)	{			if ((hashTable[i] == null) || hashTable[i].isRemoved() || key.equals(hashTable[i].getKey()))              return i; 			else // follow probe sequence				i = (i + 1) % hashTable.length; // linear probing			if (i == index)				repeated = true; // probe sequence is repeating		} // end while		return -1;	} // end probe	public Object remove(Object key)	{		Object result = null;		int i = getHashIndex(key);		i = locate(i, key);		if (i != -1) {          // key found: flag entry as removed and return its value			hashTable[i].setRemoved();			result = hashTable[i].getValue();			currentSize--;		} // end if		// else key not found: result is null		return result;	} // end remove	public Object getValue(Object key) {		Object result = null;		int i = getHashIndex(key);		i = locate(i, key);		if (i != -1)			result = hashTable[i].getValue(); // key found: get value		// else key not found: result is null		return result;	} // end getValue	/** Task: Finds the index of the key location in the hash table      * @param the hash index (from the key) and the key      * @return either the index of the entry key,      *   or -1 if no such entry is found */	private int locate(int index, Object key)	{		boolean repeated = false;		int i = index;	   // first index in sequence		while (!repeated && (hashTable[i] != null))	{ 			if (key.equals(hashTable[i].getKey()) && !hashTable[i].isRemoved())				return i;   // key found			else // follow probe sequence				i = (i + 1) % hashTable.length; // linear probing			if (i == index)				repeated = true;		} // end while      return -1; 	} // end locate	public boolean contains(Object key)	{		return getValue(key) != null; 	} // end contains   public boolean isEmpty()	{		return currentSize == 0;	} // end isEmpty	public int getSize()	{		return currentSize;	} // end getSize	private boolean isHashTableTooFull() {		return currentSize >= MAX_LOAD_FACTOR * hashTable.length;	} // end isHashTableTooFull	public int getHashIndex(Object key)	{		int hashIndex = key.hashCode() % hashTable.length;		if (hashIndex < 0)			hashIndex = hashIndex + hashTable.length;      System.out.println("\t" + key + " hashIndex = " + hashIndex);  		return hashIndex;	} // end getHashIndex	private void rehash()	{		TableEntry[] oldTable = hashTable;		int oldSize = hashTable.length;		int newSize = getNextPrime(oldSize + oldSize);		hashTable = new TableEntry[newSize]; // increase size of array		currentSize = 0; // reset size		// rehash entries from old array to the new and bigger array.       //    skip both null locations and removed entries		for (int i = 0; i < oldSize; i++) {			if ((oldTable[i] != null) && !oldTable[i].isRemoved())				add(oldTable[i].getKey(), oldTable[i].getValue());		} // end for	} // end rehash	private int getNextPrime(int integer) {      int n = integer;      boolean isPrime = false;      while(!isPrime) {         // test if number is prime         isPrime = true;   // assume prime         for (int divisor = 2; divisor <= n / 2; divisor++)            if (n % divisor == 0) {               isPrime = false;  // divisible (not prime)                  n++;              // next number                   break;            // Exit the for loop            } // end if		} // end while		return n;	} // end getNextPrime   public void display() {		for (int i = 0; i < hashTable.length; i++) {      	     	if (hashTable[i] == null)	     		System.out.println(i + " : " + "null (Empty)");	     	else if (hashTable[i].isRemoved())	     		System.out.println(i + " : " + "romoved (Available)");	     	else       		System.out.println(i + " : " + hashTable[i].getKey() + "\t" + hashTable[i].getValue());		} // end for  	} // end display	private class TableEntry {		private Object key;		private Object value;		private boolean removed; // true if entry is removed	      		private TableEntry(Object entryKey, Object entryValue)	{			key = entryKey;			value = entryValue;			removed = false;		} // end constructor				public Object getKey() {			return key;		} // end getKey				public Object getValue() {			return value;		} // end getValue				public void setValue(Object newValue) {			value = newValue;		} // end setValue		public boolean isRemoved() {			return removed;		} // end isRemoved 		public void setRemoved()	{			removed = true;		} // end setRemoved	} // end TableEntry	   } // end HashTableLinearProbing